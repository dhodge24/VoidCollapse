"""

Code was obtained from and adjusted from the references below

References:
    1) "Single-pulse phase-contrast imaging at free-electron lasers in the hard X-ray regime" by J. Hagemann et al.
    2) "Artifact-suppressing reconstruction of strongly interacting objects in X-ray near-field holography without a
    spatial support constraint" by J. Dora et al.
    3) "Shot-to-shot flat-field correction at X-ray free-electron lasers" by K. Buakor (BM3D with PCA)

The purpose of this code is to use the warped white fields and first XPC void image to generate principal components
for principal component analysis (PCA). The first XPC void image should have a good signal to noise ratio. These
components are used to generate a single flat-field corrected (FFC) image that is mitigated of low- and high-frequency
artifacts.

"""

import numpy as np
from sklearn.decomposition import PCA
from scipy.ndimage import median_filter, zoom
from tifffile import imread, imwrite

from utilities import showImg, removeOutliers
import joblib
from tqdm import tqdm
import matplotlib.pyplot as plt
import bm3d


def save_pca_model(pca_model, filename):
    """Save the PCA model"""
    joblib.dump(pca_model, filename)


def remove_outliers(originalImage, threshold=3):
    """

    Parameters
    -----------

    :param originalImage: [N, M] image for outlier removal
    :param threshold: How many standard deviations away to consider when fixing pixels

    Returns
    -----------
    :returns Fixed image [N, M]

    """

    # Handles NaN
    originalImage[np.isnan(originalImage)] = np.inf

    # Remove hot and cold pixels
    filteredImage = median_filter(originalImage, mode='nearest', size=(5, 5))
    differenceImg = (originalImage - filteredImage)  # difference between original and filtered image

    # standard deviation of gray values in difference-image, excluding infinite values
    differenceImageFinite = differenceImg[np.logical_not(np.isinf(differenceImg))]
    stdGrayVal = differenceImageFinite.std(axis=0)

    # Find pixels to correct
    pixelsToCorrect = np.abs(differenceImg) > (threshold * stdGrayVal)

    # Replace faulty pixels
    correctedImage = originalImage
    correctedImage[pixelsToCorrect] = filteredImage[pixelsToCorrect]
    return correctedImage


def downsample_image(image, downsample_factor):
    """
    Downsamples an image by some integer factor

    :param image: Ny x Nx image
    :param downsample_factor: Typically will be value 1, 2, or 4.
    :return: Downsampled image of size Ny / downsample_factor x Nx / downsample_factor
    """
    if image.ndim == 3:
        # For 3D data
        return zoom(image, zoom=(1, 1/downsample_factor, 1/downsample_factor))
    elif image.ndim == 2:
        # For 2D data
        return zoom(image, zoom=(1/downsample_factor, 1/downsample_factor))
    else:
        raise ValueError("Input image must be 2D or 3D.")


def upsample_image(image, downsample_factor):
    """
    Upsamples an image by some integer factor
    :param image: Ny x Nx image
    :param downsample_factor: Typically will be value 1, 2, or 4. Uses the sample downsample_factor for consistency
    :return: Upsampled image of size Ny * downsample_factor x Nx * downsample_factor
    """
    if image.ndim == 3:
        # For 3D data
        return zoom(image, zoom=(1, downsample_factor, downsample_factor))
    elif image.ndim == 2:
        # For 2D data
        return zoom(image, zoom=(downsample_factor, downsample_factor))
    else:
        raise ValueError("Input image must be 2D or 3D.")


def calculate_pca(ref_data, num_components, downsample_factor=4):
    """
    Performs PCA based on the reference 1) algorithm

    :param ref_data: Warped white fields -- (Nw x Ny x Nx)
    :param num_components: Number of PCA components - integer number
    :param downsample_factor: Typically will be value 1, 2, or 4
    :return: PCA model to be applied to the void image for flat-field correction
    """

    filtered_ref_data = downsample_image(ref_data, downsample_factor=downsample_factor)
    pca_model = PCA(n_components=num_components)
    pca_input_dims = [filtered_ref_data.shape[0], filtered_ref_data.shape[2] * filtered_ref_data.shape[1]]
    pca_input = filtered_ref_data.reshape(pca_input_dims)
    pca_model.fit(pca_input)
    return pca_model


def correct_flatfield(image, pca_model, plot_variance_contribution, plot_principal_components, top_left=(1450, 1925),
                      bottom_right=(1625, 2180), apply_BM3D=False, downsample_factor=4):
    """
    Performs flat-field correction using the PCA model

    :param image: Image to be flat field corrected (Ny x Nx)
    :param pca_model: PCA model generated by the calculate_pca function using the white fields
    :param plot_variance_contribution: Plots the total contribution of the contribution of each principal component
    :param plot_principal_components:  Plots the principal components
    :param top_left: Manually chosen area from which to rescale the white fields for better analysis
    :param bottom_right: Manually chosen area from which to rescale the white fields for better analysis
    :param apply_BM3D: True or False, True applies a smoothing to the principal components, can lead to better results
    :param downsample_factor: Typically will be value 1, 2, or 4
    :return: Flat-field corrected (FFC) image
    """
    Ny, Nx = image.shape

    if downsample_factor > 1:
        downsampled_image = downsample_image(image, downsample_factor)
        Ny_down, Nx_down = downsampled_image.shape
    else:
        downsampled_image = image
        Ny_down, Nx_down = Ny, Nx

    # Caution: BM3D takes a long time to run and applies to Gaussian noise type data
    if apply_BM3D:
        pca_model.components_ = pca_model.components_.reshape(pca_model.n_components_, Ny_down, Nx_down)
        denoised_components = np.zeros_like(pca_model.components_)
        print("Applying BM3D to basis (principal components):")
        for i in tqdm(range(np.shape(pca_model.components_)[0])):
            component_2d = pca_model.components_[i]
            denoised_component_2d = bm3d.bm3d(component_2d, sigma_psd=0.2, stage_arg=bm3d.BM3DStages.ALL_STAGES)
            denoised_components[i] = denoised_component_2d
        pca_model.components_ = denoised_components
        pca_model.components_ = pca_model.components_.reshape(num_components, Ny_down * Nx_down)
    else:
        # Ensure PCA components are reshaped for the downsampled size
        pca_model.mean_ = np.array(pca_model.mean_)
        pca_model.components_ = np.array(pca_model.components_).reshape(pca_model.n_components_, Ny_down * Nx_down)

    # This tells you about the percentage that the number of components captures about your data (want > 85%)
    if plot_variance_contribution:
        print(np.cumsum(pca_model.explained_variance_ratio_ * 100))
        plt.figure()
        plt.plot(np.cumsum(pca_model.explained_variance_ratio_) * 100)
        plt.xlabel('Number of Components')
        plt.ylabel('Explained Variance')
        plt.show()

    if plot_principal_components and num_components >= 4:
        first_prin_com = pca_model.components_[0].reshape(Ny_down, Nx_down)
        second_prin_com = pca_model.components_[1].reshape(Ny_down, Nx_down)
        third_prin_com = pca_model.components_[2].reshape(Ny_down, Nx_down)
        fourth_prin_com = pca_model.components_[3].reshape(Ny_down, Nx_down)

        fig2, axs2 = plt.subplots(2, 2, figsize=(10, 8))
        fig2.suptitle('Principal Components')
        top_left2 = axs2[0, 0].imshow(first_prin_com, cmap='seismic')
        axs2[0, 0].set_title("Principal Component 1")
        top_right2 = axs2[0, 1].imshow(second_prin_com, cmap='seismic')
        axs2[0, 1].set_title("Principal Component 2")
        bottom_left2 = axs2[1, 0].imshow(third_prin_com, cmap='seismic')
        axs2[1, 0].set_title("Principal Component 3")
        bottom_right2 = axs2[1, 1].imshow(fourth_prin_com, cmap='seismic')
        axs2[1, 1].set_title("Principal Component 4")
        fig2.colorbar(top_left2, ax=axs2[0, 0])
        fig2.colorbar(top_right2, ax=axs2[0, 1])
        fig2.colorbar(bottom_left2, ax=axs2[1, 0])
        fig2.colorbar(bottom_right2, ax=axs2[1, 1])
        plt.tight_layout()
        plt.show()

    # Creates the 'ideal' WF to divide our void image by, taking into account all the WFs and void image
    synthetic_flat_field = downsampled_image.reshape(np.prod(downsampled_image.shape)) - pca_model.mean_
    synthetic_flat_field = np.matmul(pca_model.components_, synthetic_flat_field)
    synthetic_flat_field = np.matmul(np.transpose(pca_model.components_, (1, 0)), synthetic_flat_field)
    synthetic_flat_field += pca_model.mean_

    # Reshape synthetic flat field and upsample if needed
    synthetic_flat_field = synthetic_flat_field.reshape(Ny_down, Nx_down)
    if downsample_factor > 1:
        synthetic_flat_field = upsample_image(synthetic_flat_field, downsample_factor)

    if rescale_wfs:
        # Choose a region where it is static and single material to rescale the white fields
        top_left = top_left  # (y, x)
        bottom_right = bottom_right  # (y, x)
        roi = image[top_left[0]:bottom_right[0], top_left[1]:bottom_right[1]]
        showImg(roi)
        mean_moving_img = np.mean(roi)
        synthetic_flat_field_reshaped = np.reshape(synthetic_flat_field, image.shape)
        roi_flat_field = synthetic_flat_field_reshaped[top_left[0]:bottom_right[0], top_left[1]:bottom_right[1]]
        mean_fixed_img = np.mean(roi_flat_field)
        # Scale moving_img (image) to make the mean of the ROI equal to that of the fixed_img's ROI
        image = image * (mean_fixed_img / mean_moving_img)

    image[np.isnan(image) | np.isinf(image)] = 0
    # Flat field correction
    corrected_image = np.divide(
        image,
        np.reshape(synthetic_flat_field, image.shape),
        out=np.zeros_like(image),  # This will place zeros in the result where division by zero would occur
        where=np.reshape(synthetic_flat_field, image.shape) != 0
    )
    corrected_image[np.isnan(corrected_image) | np.isinf(corrected_image)] = 0

    return corrected_image, synthetic_flat_field


# Options
save = True
use_img_reg_wfs = False  # Original white fields warped to dynamic image -- used only for comparisons
use_warped_wfs = True  # Original white fields warped to first white field and then warped to void image
plot_variance_contribution = False
plot_principal_components = False
plot_outputs = True
rescale_wfs = True
apply_BM3D = False
# Below: Manually choose a region where it is static and a single material to rescale the white fields
top_left = (1450, 1925)
bottom_right = (1625, 2180)

run_wfs = "562"
run_holo = "571"

# Algorithm options
num_components = 4  # 4 typically captures most of the variance
downsample_factor = 1  # For BM3D algorithm, if set to True

# Main directories
dir_main = ("/Users/danielhodge/Library/CloudStorage/Box-Box/BYU_CXI_Research_Team/ProjectFolders/SingleShotImaging/"
            "meclx4819/Tifs/run_data/")
dir_holo_preprocessed = "run" + run_holo + "_exp_preprocessed/"

if use_warped_wfs:
    dir_wfs_to_holo_img_reg = "run_" + run_wfs + "_to_" + run_holo + "_img_reg_exp_warped/"
    dir_run_warped_wf = "run" + run_wfs + "_warped_wf/"
if use_img_reg_wfs:
    dir_wfs_to_holo_img_reg = "run_" + run_wfs + "_to_" + run_holo + "_img_reg_exp/"
    dir_run_warped_wf = "run" + run_wfs + "_warped_wf/"
if not use_warped_wfs or use_img_reg_wfs:
    dir_wfs_preprocessed = "run" + run_wfs + "_exp_preprocessed/"

# Files to import
if use_warped_wfs:
    tiffs_all_warped = "*.tiff"
if use_img_reg_wfs:
    tiffs_all = "*.tiff"
if not use_warped_wfs or use_img_reg_wfs:
    tiffs_wfs_preprocessed = "run" + run_wfs + "_exp_preprocessed.tiff"
# tiffs_holo_exp_preprocessed = "run" + run_holo + "_exp_preprocessed.tiff"
tiffs_holo_exp_preprocessed = "run" + run_holo + "_exp_preprocessed_no_Talbot.tiff"

# Files to save
tiff_holo_with_speckle_ffc = "run" + run_holo + "_exp_holos_with_speckle_FFC.tiff"
tiff_holo_with_speckle_before_inpaint_ffc = "run" + run_holo + "_before_inpaint.tiff"
tiff_holo_with_speckle_syn_wf = "run" + run_holo + "_syn_with_speckle_wf.tiff"
pkl_filename = "pca_model_run" + run_holo + "_with_speckle.pkl"


# Import experimental hologram
holo_exp = np.array(imread(dir_main + dir_holo_preprocessed + tiffs_holo_exp_preprocessed), dtype=np.float32)
holo_exp = holo_exp[0, ...]

if use_warped_wfs:
    wfs = np.array(imread(dir_main +
                          dir_wfs_to_holo_img_reg +
                          dir_run_warped_wf +
                          tiffs_all_warped))
if use_img_reg_wfs:
    wfs = np.array(imread(dir_main +
                          dir_wfs_to_holo_img_reg +
                          dir_run_warped_wf +
                          tiffs_all))
if not use_warped_wfs or use_img_reg_wfs:
    wfs = np.array(imread(dir_main +
                          dir_wfs_preprocessed +
                          tiffs_wfs_preprocessed))

Ny, Nx = wfs[0, :, :].shape
pca_model = calculate_pca(ref_data=wfs,
                          num_components=num_components,
                          downsample_factor=downsample_factor)
holo_ffc, syn_wf = correct_flatfield(image=holo_exp,
                                     pca_model=pca_model,
                                     plot_variance_contribution=plot_variance_contribution,
                                     plot_principal_components=plot_principal_components,
                                     top_left=top_left,
                                     bottom_right=bottom_right,
                                     apply_BM3D=apply_BM3D,
                                     downsample_factor=downsample_factor)
syn_wf = syn_wf.reshape(Ny, Nx)
syn_wf[syn_wf < 0] = 0
holo_ffc[holo_ffc < 0] = 0
holo_ffc = removeOutliers(originalImage=holo_ffc)

if plot_outputs:
    showImg(holo_ffc, clim=(0, 2))
    showImg(syn_wf, clim=(0, 800))

if save:
    save_pca_model(pca_model, dir_main + dir_holo_preprocessed + pkl_filename)
    imwrite(dir_main + dir_holo_preprocessed + tiff_holo_with_speckle_syn_wf, syn_wf)
    imwrite(dir_main + dir_holo_preprocessed + tiff_holo_with_speckle_ffc, holo_ffc)
    imwrite(dir_main + dir_holo_preprocessed + tiff_holo_with_speckle_before_inpaint_ffc, holo_ffc)

